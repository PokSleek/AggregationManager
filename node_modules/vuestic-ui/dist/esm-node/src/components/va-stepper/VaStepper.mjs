import { defineComponent, shallowRef, ref, watch, computed, resolveComponent, openBlock, createElementBlock, mergeProps, createElementVNode, normalizeClass, withKeys, Fragment, renderList, renderSlot, normalizeProps, createCommentVNode, guardReactiveProps, createVNode, createBlock } from "vue";
import { u as useColors } from "../../composables/useColors.mjs";
import { a as useStatefulProps, b as useStateful } from "../../composables/useStateful.mjs";
import { u as useTranslation } from "../../composables/useTranslation.mjs";
import { V as VaStepperControls } from "./VaStepperControls.mjs";
import { V as VaStepperStepButton } from "./VaStepperStepButton.mjs";
import { _ as _export_sfc } from "../../../plugin-vue_export-helper.mjs";
var VaStepper_vue_vue_type_style_index_0_lang = "";
const _sfc_main = defineComponent({
  name: "VaStepper",
  components: { VaStepperControls, VaStepperStepButton },
  props: {
    ...useStatefulProps,
    modelValue: { type: Number, default: 0 },
    steps: {
      type: Array,
      default: () => [],
      required: true
    },
    color: { type: String, default: "primary" },
    vertical: { type: Boolean, default: false },
    navigationDisabled: { type: Boolean, default: false },
    controlsHidden: { type: Boolean, default: false },
    nextDisabled: { type: Boolean, default: false },
    finishButtonHidden: { type: Boolean, default: false }
  },
  emits: ["update:modelValue", "finish"],
  setup(props, { emit }) {
    const stepperNavigation = shallowRef();
    const { valueComputed: modelValue } = useStateful(props, emit, "modelValue", { defaultValue: 0 });
    const focusedStep = ref({ trigger: false, stepIndex: props.navigationDisabled ? -1 : props.modelValue });
    const { getColor } = useColors();
    const stepperColor = getColor(props.color);
    const isNextStepDisabled = (index) => props.nextDisabled && index > modelValue.value;
    const { t } = useTranslation();
    const setStep = (index) => {
      if (props.steps[index].disabled) {
        return;
      }
      emit("update:modelValue", index);
    };
    const setFocus = (direction) => {
      if (props.navigationDisabled) {
        return;
      }
      if (direction === "next") {
        setFocusNextStep(1);
      } else {
        setFocusPrevStep(1);
      }
    };
    const setFocusNextStep = (idx) => {
      const newValue = focusedStep.value.stepIndex + idx;
      if (isNextStepDisabled(newValue)) {
        return;
      }
      if (newValue < props.steps.length) {
        if (props.steps[newValue].disabled) {
          setFocusNextStep(idx + 1);
          return;
        }
        focusedStep.value.stepIndex = newValue;
        focusedStep.value.trigger = true;
      } else {
        for (let availableIdx = 0; availableIdx < props.steps.length; availableIdx++) {
          if (!props.steps[availableIdx].disabled) {
            focusedStep.value.stepIndex = availableIdx;
            focusedStep.value.trigger = true;
            break;
          }
        }
      }
    };
    const setFocusPrevStep = (idx) => {
      const newValue = focusedStep.value.stepIndex - idx;
      if (newValue >= 0) {
        if (props.steps[newValue].disabled) {
          setFocusPrevStep(idx + 1);
          return;
        }
        focusedStep.value.stepIndex = newValue;
        focusedStep.value.trigger = true;
      } else {
        for (let availableIdx = props.steps.length - 1; availableIdx >= 0; availableIdx--) {
          if (!props.steps[availableIdx].disabled && !isNextStepDisabled(availableIdx)) {
            focusedStep.value.stepIndex = availableIdx;
            focusedStep.value.trigger = true;
            break;
          }
        }
      }
    };
    const resetFocus = () => {
      requestAnimationFrame(() => {
        var _a;
        if (!((_a = stepperNavigation.value) == null ? void 0 : _a.contains(document.activeElement))) {
          focusedStep.value.stepIndex = props.modelValue;
          focusedStep.value.trigger = false;
        }
      });
    };
    watch(() => props.modelValue, () => {
      focusedStep.value.stepIndex = props.modelValue;
      focusedStep.value.trigger = false;
    });
    const nextStep = (stepsToSkip = 0) => {
      const targetIndex = modelValue.value + 1 + stepsToSkip;
      if (!props.steps[targetIndex]) {
        return;
      }
      if (props.steps[targetIndex].disabled) {
        nextStep(stepsToSkip + 1);
      }
      setStep(targetIndex);
    };
    const prevStep = (stepsToSkip = 0) => {
      const targetIndex = modelValue.value - 1 - stepsToSkip;
      if (!props.steps[targetIndex]) {
        return;
      }
      if (props.steps[targetIndex].disabled) {
        prevStep(stepsToSkip + 1);
      }
      setStep(targetIndex);
    };
    const stepControls = { setStep, nextStep, prevStep };
    const getIterableSlotData = (step, index) => ({
      ...stepControls,
      step,
      focus: focusedStep,
      isActive: props.modelValue === index,
      isCompleted: props.modelValue > index
    });
    return {
      stepperNavigation,
      resetFocus,
      focusedStep,
      isNextStepDisabled,
      stepperColor,
      getColor,
      stepControls,
      getIterableSlotData,
      onArrowKeyPress: (direction) => {
        setFocus(direction);
      },
      onValueChange: () => {
        focusedStep.value.stepIndex = props.modelValue;
        focusedStep.value.trigger = true;
      },
      ariaAttributesComputed: computed(() => ({
        role: "group",
        "aria-label": t("progress"),
        "aria-orientation": props.vertical ? "vertical" : "horizontal"
      }))
    };
  }
});
const _hoisted_1 = {
  key: 0,
  class: "va-stepper__step-content"
};
const _hoisted_2 = { class: "va-stepper__controls" };
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_va_stepper_step_button = resolveComponent("va-stepper-step-button");
  const _component_va_stepper_controls = resolveComponent("va-stepper-controls");
  return openBlock(), createElementBlock("div", mergeProps({
    class: ["va-stepper", { "va-stepper--vertical": _ctx.$props.vertical }]
  }, _ctx.ariaAttributesComputed), [
    createElementVNode("ol", {
      class: normalizeClass(["va-stepper__navigation", { "va-stepper__navigation--vertical": _ctx.$props.vertical }]),
      ref: "stepperNavigation",
      onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onValueChange && _ctx.onValueChange(...args)),
      onKeyup: [
        _cache[1] || (_cache[1] = withKeys((...args) => _ctx.onValueChange && _ctx.onValueChange(...args), ["enter"])),
        _cache[2] || (_cache[2] = withKeys((...args) => _ctx.onValueChange && _ctx.onValueChange(...args), ["space"])),
        _cache[3] || (_cache[3] = withKeys(($event) => _ctx.onArrowKeyPress("prev"), ["left"])),
        _cache[4] || (_cache[4] = withKeys(($event) => _ctx.onArrowKeyPress("next"), ["right"]))
      ],
      onFocusout: _cache[5] || (_cache[5] = (...args) => _ctx.resetFocus && _ctx.resetFocus(...args))
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$props.steps, (step, i) => {
        return openBlock(), createElementBlock(Fragment, { key: i }, [
          i > 0 ? renderSlot(_ctx.$slots, "divider", normalizeProps(mergeProps({ key: 0 }, _ctx.getIterableSlotData(step, i))), () => [
            createElementVNode("span", {
              class: normalizeClass(["va-stepper__divider", { "va-stepper__divider--vertical": _ctx.$props.vertical }]),
              "aria-hidden": "true"
            }, null, 2)
          ]) : createCommentVNode("", true),
          renderSlot(_ctx.$slots, `step-button-${i}`, normalizeProps(guardReactiveProps(_ctx.getIterableSlotData(step, i))), () => [
            createVNode(_component_va_stepper_step_button, {
              stepIndex: i,
              color: _ctx.stepperColor,
              modelValue: _ctx.modelValue,
              nextDisabled: _ctx.nextDisabled,
              step,
              stepControls: _ctx.stepControls,
              navigationDisabled: _ctx.navigationDisabled,
              focus: _ctx.focusedStep
            }, null, 8, ["stepIndex", "color", "modelValue", "nextDisabled", "step", "stepControls", "navigationDisabled", "focus"])
          ])
        ], 64);
      }), 128))
    ], 34),
    createElementVNode("div", {
      class: normalizeClass(["va-stepper__step-content-wrapper", { "va-stepper__step-content-wrapper--vertical": _ctx.$props.vertical }])
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.$props.steps, (step, i) => {
        return openBlock(), createElementBlock(Fragment, { key: i }, [
          _ctx.$slots[`step-content-${i}`] && _ctx.modelValue === i ? (openBlock(), createElementBlock("div", _hoisted_1, [
            renderSlot(_ctx.$slots, `step-content-${i}`, normalizeProps(guardReactiveProps(_ctx.getIterableSlotData(step, i))))
          ])) : createCommentVNode("", true)
        ], 64);
      }), 128)),
      createElementVNode("div", _hoisted_2, [
        !_ctx.controlsHidden ? (openBlock(), createBlock(_component_va_stepper_controls, {
          key: 0,
          modelValue: _ctx.modelValue,
          nextDisabled: _ctx.nextDisabled,
          steps: _ctx.steps,
          stepControls: _ctx.stepControls,
          onFinish: _cache[6] || (_cache[6] = ($event) => _ctx.$emit("finish"))
        }, null, 8, ["modelValue", "nextDisabled", "steps", "stepControls"])) : createCommentVNode("", true),
        renderSlot(_ctx.$slots, "controls", normalizeProps(guardReactiveProps(_ctx.stepControls)))
      ])
    ], 2)
  ], 16);
}
var _VaStepper = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export { _VaStepper as _ };
//# sourceMappingURL=VaStepper.mjs.map
